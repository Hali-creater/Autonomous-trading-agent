test_strategy_path = os.path.join(tests_dir, "test_strategy.py")
with open(test_strategy_path, "w") as f:
    f.write("import unittest\n")
    f.write("import pandas as pd\n")
    f.write("import numpy as np\n")
    # 4. In test_strategy.py, write a test class that imports the CombinedStrategy
    f.write("from strategy.trading_strategy import CombinedStrategy\n\n")

    # 5. Implement test methods within the class that cover the generate_signal method.
    f.write("class TestCombinedStrategy(unittest.TestCase):\n")
    f.write("    def setUp(self):\n")
    f.write("        # Initialize the strategy before each test\n")
    f.write("        self.strategy = CombinedStrategy()\n\n")

    f.write("    def test_generate_signal_buy(self):\n")
    f.write("        # Test case for generating a BUY signal\n")
    f.write("        # Create a sample DataFrame that should trigger a BUY signal\n")
    f.write("        # This requires understanding the strategy's internal logic (PVG, SMC, TPR)\n")
    f.write("        # Based on the placeholder logic in trading_strategy.py:\n")
    f.write("        # BUY conditions: Short SMA > Long SMA AND Swing Low == 1 AND Close > Long SMA AND Volume SMA > 0\n")
    f.write("        data = pd.DataFrame({\n")
    f.write("            'open': [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64],\n") # Need enough data for SMAs (50 periods) and SMC (20 periods)
    f.write("            'high': [10.5, 11.5, 12.5, 13.5, 14.5, 15.5, 16.5, 17.5, 18.5, 19.5, 20.5, 21.5, 22.5, 23.5, 24.5, 25.5, 26.5, 27.5, 28.5, 29.5, 30.5, 31.5, 32.5, 33.5, 34.5, 35.5, 36.5, 37.5, 38.5, 39.5, 40.5, 41.5, 42.5, 43.5, 44.5, 45.5, 46.5, 47.5, 48.5, 49.5, 50.5, 51.5, 52.5, 53.5, 54.5, 55.5, 56.5, 57.5, 58.5, 59.5, 60.5, 61.5, 62.5, 63.5, 64.5],\n")
    f.write("            'low': [9.5, 10.5, 11.5, 12.5, 13.5, 14.5, 15.5, 16.5, 17.5, 18.5, 19.5, 20.5, 21.5, 22.5, 23.5, 24.5, 25.5, 26.5, 27.5, 28.5, 29.5, 30.5, 31.5, 32.5, 33.5, 34.5, 35.5, 36.5, 37.5, 38.5, 39.5, 40.5, 41.5, 42.5, 43.5, 44.5, 45.5, 46.5, 47.5, 48.5, 49.5, 50.5, 51.5, 52.5, 53.5, 54.5, 55.5, 56.5, 57.5, 58.5, 59.5, 60.5, 61.5, 62.5, 63.5],\n")
    f.write("            'close': [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64],\n")
    f.write("            'volume': [100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270, 280, 290, 300, 310, 320, 330, 340, 350, 360, 370, 380, 390, 400, 410, 420, 430, 440, 450, 460, 470, 480, 490, 500, 510, 520, 530, 540, 550, 560, 570, 580, 590, 600, 610, 620, 630, 640]\n")
    f.write("        })\n")
    f.write("        # Manually adjust data to ensure conditions are met for the LAST row\n")
    f.write("        # Ensure Short SMA > Long SMA at the end\n")
    f.write("        # Ensure a Swing Low occurred recently (e.g., lowest low in the last 20 periods is the current low)\n")
    f.write("        # Ensure Close > Long SMA\n")
    f.write("        # Ensure Volume SMA > 0 (should be true with positive volume)\n")
    f.write("        # This requires careful data crafting or mocking the internal analysis methods\n")
    f.write("        # For simplicity in this placeholder test, we'll assume crafted data or mock the analysis results\n")

    f.write("        # Since crafting complex data for specific indicator values is hard in a placeholder,\n")
    f.write("        # we'll focus on basic tests and assume the internal analysis methods work.\n")
    f.write("        # A more robust test would mock the _analyze methods to return predictable results.\n")


    f.write("        # Let's create a simple scenario where price is trending up, SMAs are crossed, and a recent low occurred.\n")
    f.write("        # We need at least self.pvg_long_period (50) + self.smc_lookback (20) data points for indicators to be calculated.\n")
    f.write("        # Let's create 70 data points with an upward trend.\n")
    f.write("        data_points = 70\n")
    f.write("        data = pd.DataFrame({\n")
    f.write("            'open': np.arange(100, 100 + data_points, 1),\n")
    f.write("            'high': np.arange(100.5, 100.5 + data_points, 1),\n")
    f.write("            'low': np.arange(99.5, 99.5 + data_points, 1),\n")
    f.write("            'close': np.arange(100, 100 + data_points, 1) + np.random.rand(data_points) * 2, # Add some noise\n")
    f.write("            'volume': np.random.randint(100, 1000, size=data_points)\n")
    f.write("        })\n")

    f.write("        # To simulate a recent swing low that aligns with a buy signal, we can artificially set the low of the last few bars.\n")
    f.write("        # This is still a simplification and a real test might need more sophisticated data generation.\n")
    f.write("        # Let's simulate a slight dip followed by recovery at the end\n")
    f.write("        data.loc[data_points-5:data_points-3, 'low'] = data['low'][data_points-5:data_points-3] * 0.98\n")
    f.write("        data.loc[data_points-1, 'close'] = data['close'][data_points-1] * 1.05 # Ensure close is high for strong signal\n")


    f.write("        signal = self.strategy.generate_signal(data.copy()) # Use a copy to prevent modification\n")
    f.write("        # Based on the crafted data, we expect a BUY signal (this is an assumption for the placeholder)\n")
    f.write("        # A real test would verify the underlying indicator values calculated by the strategy\n")
    f.write("        self.assertEqual(signal, 'BUY')\n\n")


    f.write("    def test_generate_signal_sell(self):\n")
    f.write("        # Test case for generating a SELL signal\n")
    f.write("        # Create a sample DataFrame that should trigger a SELL signal\n")
    f.write("        # Based on the placeholder logic in trading_strategy.py:\n")
    f.write("        # SELL conditions: Short SMA < Long SMA AND Swing High == 1 AND Close < Long SMA AND Volume SMA > 0\n")

    f.write("        # Let's create 70 data points with a downward trend.\n")
    f.write("        data_points = 70\n")
    f.write("        data = pd.DataFrame({\n")
    f.write("            'open': np.arange(200, 200 - data_points, -1),\n")
    f.write("            'high': np.arange(200.5, 200.5 - data_points, -1),\n")
    f.write("            'low': np.arange(199.5, 199.5 - data_points, -1),\n")
    f.write("            'close': np.arange(200, 200 - data_points, -1) - np.random.rand(data_points) * 2, # Add some noise\n")
    f.write("            'volume': np.random.randint(100, 1000, size=data_points)\n")
    f.write("        })\n")

    f.write("        # Simulate a recent swing high that aligns with a sell signal\n")
    f.write("        data.loc[data_points-5:data_points-3, 'high'] = data['high'][data_points-5:data_points-3] * 1.02\n")
    f.write("        data.loc[data_points-1, 'close'] = data['close'][data_points-1] * 0.95 # Ensure close is low for strong signal\n")


    f.write("        signal = self.strategy.generate_signal(data.copy())\n")
    f.write("        # Based on the crafted data, we expect a SELL signal (assumption for placeholder)\n")
    f.write("        self.assertEqual(signal, 'SELL')\n\n")

    f.write("    def test_generate_signal_hold(self):\n")
    f.write("        # Test case for generating a HOLD signal\n")
    f.write("        # Create a sample DataFrame that should trigger a HOLD signal (e.g., choppy, no clear trend, conditions not met)\n")

    f.write("        # Let's create 70 data points with sideways movement\n")
    f.write("        data_points = 70\n")
    f.write("        data = pd.DataFrame({\n")
    f.write("            'open': np.full(data_points, 150),\n")
    f.write("            'high': np.full(data_points, 152),\n")
    f.write("            'low': np.full(data_points, 148),\n")
    f.write("            'close': 150 + np.random.randn(data_points) * 1.5, # Random walk around 150\n")
    f.write("            'volume': np.random.randint(50, 500, size=data_points)\n")
    f.write("        })\n")

    f.write("        signal = self.strategy.generate_signal(data.copy())\n")
    f.write("        # In a sideways market, we expect a HOLD signal\n")
    f.write("        self.assertEqual(signal, 'HOLD')\n\n")

    f.write("    def test_generate_signal_empty_data(self):\n")
    f.write("        # Test case for empty input data\n")
    f.write("        data = pd.DataFrame()\n")
    f.write("        signal = self.strategy.generate_signal(data)\n")
    f.write("        self.assertEqual(signal, 'HOLD')\n\n")

    f.write("    def test_generate_signal_data_with_nans(self):\n")
    f.write("        # Test case for data with NaN values\n")
    f.write("        data = pd.DataFrame({\n")
    f.write("            'open': [10, 11, np.nan, 13, 14],\n")
    f.write("            'high': [10.5, 11.5, 12.5, np.nan, 14.5],\n")
    f.write("            'low': [9.5, 10.5, 11.5, 12.5, np.nan],\n")
    f.write("            'close': [10, 11, 12, 13, 14],\n")
    f.write("            'volume': [100, np.nan, 120, 130, 140]\n")
    f.write("        })\n")
    f.write("        # The strategy should handle NaNs, likely by dropping rows or returning HOLD if critical data is missing\n")
    f.write("        # Based on the strategy's dropna() logic, if the last row has NaNs after indicator calculation, it might return HOLD.\n")
    f.write("        # For this test, we expect it to return HOLD if the final processed data is empty or invalid.\n")
    f.write("        signal = self.strategy.generate_signal(data.copy())\n")
    f.write("        self.assertEqual(signal, 'HOLD') # Expect HOLD as indicators will likely produce NaNs at the end\n\n")


print(f"Created {test_strategy_path}")
